{
  "cpp snippets": {
    "prefix": "boilerplate",
    "body": [
      "/*          || जय श्री राम || ॐ नमः शिवाय || हर हर महादेव || जय बजरंग बली || */",
      "",
      "/*",
      "Name: Adarsh",
      "Date: ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR}",
      "Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
      "Link: https://codeforces.com/profile/hakdcode_1",
      "Problem: ${TM_FILENAME_BASE}",
      "*/",
      "",
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define mod 1000000007",
      "#define pi 3.1415926535897932384626433832795",
      "#define all(cont) cont.begin(), cont.end()",
      "#define rall(cont) cont.rbegin(), cont.rend()",
      "typedef long long ll;",
      "#define vc(x) vector<x>",
      "#define pr(x, y) pair<x, y>",
      "#define sz(x) (int)x.size()",
      "#define sg(x) set<x, greater<x>>",
      "#define msg(x) multiset<x, greater<x>>",
      "#define ms(x) multiset<x>",
      "#define um(x, y) unordered_map<x, y>",
      "#define pq(x) priority_queue<x>",
      "#define pqg(x) priority_queue<x, vector<x>, greater<x>>",
      "#define mem(a, b) memset(a, b, sizeof(a))",
      "#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
      "#define fileio freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);",
      "#define debug(x) cout << #x << \" \" << x << endl;",
      "#define f first",
      "#define s second",
      "#define pb push_back",
      "#define fr(i,a,b) for(int i=a;i<b;i++)",
      "#define rf(i,a,b) for(int i=a;i>=b;i--)",
      "#define foreach(it,a) for(auto it = a.begin(); it != a.end(); it++)",
      "#define endl \"\\n\"",
      "#define inf (int)1e9",
      "#define linf (long long)1e18",
      "#define eps 1e-9",
      "#include<ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T>using Tree = tree<",
      "    T, null_type, less<T>,",
      "    rb_tree_tag, tree_order_statistics_node_update",
      ">;",
      "",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};",
      "",
      "void yes(){cout << \"YES\" << endl;}",
      "void no(){cout << \"NO\" << endl;}",
      "",
      "void solve(){",
      "",
      "}",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    cout.precision(10);",
      "    cout << fixed;",
      "",
      "    int t = 1;",
      "    cin >> t;",
      "",
      "    while(t--)",
      "        solve();",
      "",
      "    return 0;",
      "}"
    ],
    "description": "to produce the main snippet for cpp"
  },
  "binary_lifting": {
    "prefix": "lca",
    "body": [
      "class BinaryLifting{",
      "    private:",
      "        vector<vector<int>> up;",
      "        vector<int> lvl;",
      "    ",
      "    public:",
      "        BinaryLifting(int n){",
      "            up.resize(n+1, vector<int>(20, -1));",
      "            lvl.resize(n+1, -1);",
      "        }",
      "",
      "        void dfs(int src, int par, vector<int> adj[], int level=0){",
      "            lvl[src] = level;",
      "            for(auto it: adj[src]){",
      "                if(it == par) continue;",
      "                dfs(it, src, adj, level + 1);",
      "            }",
      "        }",
      "",
      "        void binaryLifting(int src, int par, vector<int> adj[]){",
      "            up[src][0] = par;",
      "            for(int i=1; i<20; i++){",
      "                if(up[src][i-1] != -1){",
      "                    up[src][i] = up[up[src][i-1]][i-1];",
      "                }else up[src][i] = -1;",
      "            }",
      "        ",
      "            for(auto it: adj[src]){",
      "                if(it == par) continue;",
      "                binaryLifting(it, src, adj);",
      "            }",
      "        }",
      "",
      "        void binaryLifting(vector<int>& par, int n){",
      "            for(int i=0; i<=n; i++) up[i][0] = par[i];",
      "            for(int i=1; i<20; i++){",
      "                for(int j=1; j<=n; j++){",
      "                    if(up[j][i-1] != -1)",
      "                        up[j][i] = up[up[j][i-1]][i-1];",
      "                    else up[j][i] = -1;",
      "                }",
      "            }",
      "        }",
      "         ",
      "        int liftNode(int node, int k){",
      "            if(k == 0 || node == -1) return node;",
      "            for(int i=19; i>=0; i--){",
      "                if(k & (1 << i)){",
      "                    node = up[node][i];",
      "                }",
      "            }",
      "            return node;",
      "        }",
      "",
      "        int LCA(int u, int v){",
      "            if(lvl[u] < lvl[v]) swap(u, v);",
      "            u = liftNode(u, lvl[u] - lvl[v]);",
      "            if(u == v) return u;",
      "            for(int i=19; i>=0; i--){",
      "                if(up[u][i] != up[v][i]){",
      "                    u = up[u][i];",
      "                    v = up[v][i];",
      "                }",
      "            }",
      "            return liftNode(u, 1);",
      "        }",
      "};"
    ],
    "description": "binary_lifting"
  },
  "Trie": {
    "prefix": "trie",
    "body": [
      "class Trie{",
      "    private:",
      "    struct Node{",
      "        Node* links[26];",
      "        bool flag = false;",
      "",
      "        bool containsKey(char c){",
      "            return links[c - 'a'] != NULL;",
      "        }",
      "",
      "        void put(char c, Node* node){",
      "            links[c - 'a'] = node;",
      "        }",
      "",
      "        Node* get(char c){",
      "            return links[c - 'a'];",
      "        }",
      "",
      "        bool isEnd(){",
      "            return flag;",
      "        }",
      "",
      "        void setEnd(){",
      "            flag = true;",
      "        }",
      "    };",
      "    Node* root;",
      "    public:",
      "        Trie(){",
      "            root = new Node();",
      "        }",
      "        int ans = 0;",
      "        void insert(string& s){",
      "            Node* node = root;",
      "            for(auto it: s){",
      "                if(!node -> containsKey(it)) node -> put(it, new Node());",
      "                node = node -> get(it);",
      "            }",
      "            node -> setEnd();",
      "        }",
      "};"
    ],
    "description": "Trie"
    },
    "Start_Template": {
      "prefix": "start",
      "body": [
        "/*",
        "Name: Adarsh",
        "Date: ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR}",
        "Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "*/",
        "",
        "#include<bits/stdc++.h>",
        "using namespace std;",
        "",
  
        "int main(){",
        "",
        "    return 0;",
        "}"
      ],
      "description": "to produce the main snippet for cpp"
    },
    "SegmentTree": {
      "prefix": "sgtree",
      "body": [
        "class SGTree{",
        "    vector<int> seg;",
        "    public:",
        "    // segment tree constructor for defining the size",
        "    SGTree(int n){",
        "        seg.assign(4 * n + 1, -1);",
        "    }",
        "    // operation function",
        "    int comp(int a, int b){",
        "        return min(a, b);",
        "    }",
        "    // for building the segment tree",
        "    void build(int ind, int left, int right, vector<int>& arr){",
        "        // when on the leaf node, add the value to the segment",
        "        if(left == right){",
        "            seg[ind] = arr[left];",
        "            return;",
        "        }",
        "        // now go on the build the left and right subtree",
        "        int mid = left + (right - left) / 2;",
        "        // left subtree",
        "        build(2 * ind + 1, left, mid, arr);",
        "        // right subtree",
        "        build(2 * ind + 2, mid + 1, right, arr);",
        "        // operation which you need to perform on the subtree",
        "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
        "    }",
        "    // for the query of the data",
        "    int query(int ind, int left, int right, int l, int r){",
        "        // when the segment is not in the range (disjoint)",
        "        if(r < left || l > right) return INT_MAX;",
        "        // when fully in the range ",
        "        if(l <= left && right <= r){",
        "            return seg[ind];",
        "        }",
        "        // partial overlapping",
        "        int mid = left + (right - left) / 2;",
        "        int leftC = query(2 * ind + 1, left, mid, l, r);",
        "        int rightC = query(2 * ind + 2, mid + 1, right, l, r);",
        "        // operation which you need to perform on the subtree",
        "        return comp(leftC , rightC);",
        "    }",
        "    // point update for the tree",
        "    void update(int ind, int left, int right, vector<int>& arr, int pos, int val){",
        "        // when on the leaf node, update the value",
        "        if(left == right){",
        "            arr[pos] = val;",
        "            seg[ind] = val;",
        "            return;",
        "        }",
        "        // now check on the left and right",
        "        int mid = left + (right - left) / 2;",
        "        // when the position which need to be update is in left",
        "        if(left <= pos && pos <= mid){",
        "            update(2 * ind + 1, left, mid, arr, pos, val);",
        "        }else update(2 * ind + 2, mid + 1, right, arr, pos, val);",
        "        // operation which you need to perform on the tree",
        "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
        "    }",
        " ",
        "};"
      ],
      "description": "SegmentTreeImplementation"
      },
      "DSU": {
        "prefix": "dsu",
        "body": [
          "class DisjointSet{",
          "   vector<int> rank, size, parent;",
          "public:",
          "   DisjointSet(int n){",
          "     rank.resize(n+1,0);",
          "     size.resize(n+1,0);",
          "     parent.resize(n+1);",
          "     for(int i=0; i<=n; i++){",
          "        parent[i] = i;",
          "       size[i] = 1;",
          "     }",
          "   }",
          "   int findPar(int node){",
          "     if(node == parent[node])",
          "       return node;",
          "     return parent[node] = findPar(parent[node]);",
          "   }",
          "",
          "   void unionByRank(int u, int v){",
          "     int ulp_u = findPar(u);",
          "     int ulp_v = findPar(v);",
          "",
          "     if(ulp_u == ulp_v) return;",
          "     if(rank[ulp_u] < rank[ulp_v]){",
          "       parent[ulp_u] = ulp_v;",
          "     }else if(rank[ulp_u] > rank[ulp_v]){",
          "       parent[ulp_v] = ulp_u;",
          "     }else{",
          "       parent[ulp_v] = ulp_u;",
          "       rank[ulp_u]++;",
          "     }",
          "   }",
          "",
          "   void unionBySize(int u, int v){",
          "     int ulp_u = findPar(u);",
          "     int ulp_v = findPar(v);",
          "",
          "     if(ulp_u == ulp_v) return;",
          "     if(size[ulp_u] < size[ulp_v]){",
          "       parent[ulp_u] = ulp_v;",
          "       size[ulp_v] += size[ulp_u];",
          "     }else{",
          "       parent[ulp_v] = ulp_u;",
          "       size[ulp_u] += size[ulp_v];",
          "     }",
          "   }",
          "};",
        ],
        "description": "to add the disjoint set class in the cpp code"
        }
}
