// Write this code in the cpp.json file
{
  "cpp snippets": {
    "prefix": "boilerplate",
    "body": [
      "/*          || जय श्री राम || ॐ नमः शिवाय || हर हर महादेव || जय बजरंग बली || */",
      "",
      "/*",
      "Name: Adarsh",
      "Date: ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR}",
      "Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
      "Link: https://codeforces.com/profile/hakdcode_1",
      "Problem: ${TM_FILENAME_BASE}",
      "*/",
      "",
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define mod 1000000007",
      "#define pi 3.1415926535897932384626433832795",
      "#define all(cont) cont.begin(), cont.end()",
      "#define rall(cont) cont.rbegin(), cont.rend()",
      "typedef long long ll;",
      "#define vc(x) vector<x>",
      "#define pr(x, y) pair<x, y>",
      "#define sz(x) (int)x.size()",
      "#define sg(x) set<x, greater<x>>",
      "#define msg(x) multiset<x, greater<x>>",
      "#define ms(x) multiset<x>",
      "#define um(x, y) unordered_map<x, y>",
      "#define pq(x) priority_queue<x>",
      "#define pqg(x) priority_queue<x, vector<x>, greater<x>>",
      "#define mem(a, b) memset(a, b, sizeof(a))",
      "#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
      "#define fileio freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);",
      "#define debug(x) cout << #x << \" \" << x << endl;",
      "#define f first",
      "#define s second",
      "#define pb push_back",
      "#define fr(i,a,b) for(int i=a;i<b;i++)",
      "#define rf(i,a,b) for(int i=a;i>=b;i--)",
      "#define foreach(it,a) for(auto it = a.begin(); it != a.end(); it++)",
      "#define endl \"\\n\"",
      "#define inf (int)1e9",
      "#define linf (long long)1e18",
      "#define eps 1e-9",
      "#include<ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T>using Tree = tree<",
      "    T, null_type, less<T>,",
      "    rb_tree_tag, tree_order_statistics_node_update",
      ">;",
      "",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};",
      "",
      "void yes(){cout << \"YES\" << endl;}",
      "void no(){cout << \"NO\" << endl;}",
      "",
      "void solve(){",
      "",
      "}",
      "",
      "int main()",
      "{",
      "    fastio;",
      "    cout.precision(10);",
      "    cout << fixed;",
      "",
      "    int t = 1;",
      "    cin >> t;",
      "",
      "    while(t--)",
      "        solve();",
      "",
      "    return 0;",
      "}"
    ],
    "description": "to produce the main snippet for cpp"
  },
  "binary_lifting": {
    "prefix": "lca",
    "body": [
      "class BinaryLifting{",
      "    private:",
      "        vector<vector<int>> up;",
      "        vector<int> lvl;",
      "    ",
      "    public:",
      "        BinaryLifting(int n){",
      "            up.resize(n+1, vector<int>(20, -1));",
      "            lvl.resize(n+1, -1);",
      "        }",
      "",
      "        void dfs(int src, int par, vector<int> adj[], int level=0){",
      "            lvl[src] = level;",
      "            for(auto it: adj[src]){",
      "                if(it == par) continue;",
      "                dfs(it, src, adj, level + 1);",
      "            }",
      "        }",
      "",
      "        void binaryLifting(int src, int par, vector<int> adj[]){",
      "            up[src][0] = par;",
      "            for(int i=1; i<20; i++){",
      "                if(up[src][i-1] != -1){",
      "                    up[src][i] = up[up[src][i-1]][i-1];",
      "                }else up[src][i] = -1;",
      "            }",
      "        ",
      "            for(auto it: adj[src]){",
      "                if(it == par) continue;",
      "                binaryLifting(it, src, adj);",
      "            }",
      "        }",
      "",
      "        void binaryLifting(vector<int>& par, int n){",
      "            for(int i=0; i<=n; i++) up[i][0] = par[i];",
      "            for(int i=1; i<20; i++){",
      "                for(int j=1; j<=n; j++){",
      "                    if(up[j][i-1] != -1)",
      "                        up[j][i] = up[up[j][i-1]][i-1];",
      "                    else up[j][i] = -1;",
      "                }",
      "            }",
      "        }",
      "         ",
      "        int liftNode(int node, int k){",
      "            if(k == 0 || node == -1) return node;",
      "            for(int i=19; i>=0; i--){",
      "                if(k & (1 << i)){",
      "                    node = up[node][i];",
      "                }",
      "            }",
      "            return node;",
      "        }",
      "",
      "        int LCA(int u, int v){",
      "            if(lvl[u] < lvl[v]) swap(u, v);",
      "            u = liftNode(u, lvl[u] - lvl[v]);",
      "            if(u == v) return u;",
      "            for(int i=19; i>=0; i--){",
      "                if(up[u][i] != up[v][i]){",
      "                    u = up[u][i];",
      "                    v = up[v][i];",
      "                }",
      "            }",
      "            return liftNode(u, 1);",
      "        }",
      "        int dis(int u, int v){",
      "            int lca = LCA(u, v);",
      "            return lvl[u] + lvl[v] - 2 * lvl[lca];",
      "        }",
      "};"
    ],
    "description": "binary_lifting"
  },
  "Trie": {
    "prefix": "trie",
    "body": [
      "class Trie{",
      "    private:",
      "    struct Node{",
      "        Node* links[26];",
      "        bool flag = false;",
      "",
      "        bool containsKey(char c){",
      "            return links[c - 'a'] != NULL;",
      "        }",
      "",
      "        void put(char c, Node* node){",
      "            links[c - 'a'] = node;",
      "        }",
      "",
      "        Node* get(char c){",
      "            return links[c - 'a'];",
      "        }",
      "",
      "        bool isEnd(){",
      "            return flag;",
      "        }",
      "",
      "        void setEnd(){",
      "            flag = true;",
      "        }",
      "    };",
      "    Node* root;",
      "    public:",
      "        Trie(){",
      "            root = new Node();",
      "        }",
      "        int ans = 0;",
      "        void insert(string& s){",
      "            Node* node = root;",
      "            for(auto it: s){",
      "                if(!node -> containsKey(it)) node -> put(it, new Node());",
      "                node = node -> get(it);",
      "            }",
      "            node -> setEnd();",
      "        }",
      "};"
    ],
    "description": "Trie"
    },
    "Start_Template": {
      "prefix": "start",
      "body": [
        "/*",
        "Name: Adarsh",
        "Date: ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR}",
        "Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "*/",
        "",
        "#include<bits/stdc++.h>",
        "using namespace std;",
        "",
  
        "int main(){",
        "",
        "    return 0;",
        "}"
      ],
      "description": "to produce the main snippet for cpp"
    },
    "SegmentTree": {
      "prefix": "sgtree",
      "body": [
        "class SGTree{",
        "    vector<int> seg;",
        "    public:",
        "    // segment tree constructor for defining the size",
        "    SGTree(int n){",
        "        seg.assign(4 * n + 1, -1);",
        "    }",
        "    // operation function",
        "    int comp(int a, int b){",
        "        return min(a, b);",
        "    }",
        "    // for building the segment tree",
        "    void build(int ind, int left, int right, vector<int>& arr){",
        "        // when on the leaf node, add the value to the segment",
        "        if(left == right){",
        "            seg[ind] = arr[left];",
        "            return;",
        "        }",
        "        // now go on the build the left and right subtree",
        "        int mid = left + (right - left) / 2;",
        "        // left subtree",
        "        build(2 * ind + 1, left, mid, arr);",
        "        // right subtree",
        "        build(2 * ind + 2, mid + 1, right, arr);",
        "        // operation which you need to perform on the subtree",
        "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
        "    }",
        "    // for the query of the data",
        "    int query(int ind, int left, int right, int l, int r){",
        "        // when the segment is not in the range (disjoint)",
        "        if(r < left || l > right) return INT_MAX;",
        "        // when fully in the range ",
        "        if(l <= left && right <= r){",
        "            return seg[ind];",
        "        }",
        "        // partial overlapping",
        "        int mid = left + (right - left) / 2;",
        "        int leftC = query(2 * ind + 1, left, mid, l, r);",
        "        int rightC = query(2 * ind + 2, mid + 1, right, l, r);",
        "        // operation which you need to perform on the subtree",
        "        return comp(leftC , rightC);",
        "    }",
        "    // point update for the tree",
        "    void update(int ind, int left, int right, vector<int>& arr, int pos, int val){",
        "        // when on the leaf node, update the value",
        "        if(left == right){",
        "            arr[pos] = val;",
        "            seg[ind] = val;",
        "            return;",
        "        }",
        "        // now check on the left and right",
        "        int mid = left + (right - left) / 2;",
        "        // when the position which need to be update is in left",
        "        if(left <= pos && pos <= mid){",
        "            update(2 * ind + 1, left, mid, arr, pos, val);",
        "        }else update(2 * ind + 2, mid + 1, right, arr, pos, val);",
        "        // operation which you need to perform on the tree",
        "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
        "    }",
        " ",
        "};"
      ],
      "description": "SegmentTreeImplementation"
      },
      "DSU": {
        "prefix": "dsu",
        "body": [
          "class DisjointSet{",
          "   vector<int> rank, size, parent;",
          "public:",
          "   DisjointSet(int n){",
          "     rank.resize(n+1,0);",
          "     size.resize(n+1,0);",
          "     parent.resize(n+1);",
          "     for(int i=0; i<=n; i++){",
          "        parent[i] = i;",
          "       size[i] = 1;",
          "     }",
          "   }",
          "   int findPar(int node){",
          "     if(node == parent[node])",
          "       return node;",
          "     return parent[node] = findPar(parent[node]);",
          "   }",
          "",
          "   void unionByRank(int u, int v){",
          "     int ulp_u = findPar(u);",
          "     int ulp_v = findPar(v);",
          "",
          "     if(ulp_u == ulp_v) return;",
          "     if(rank[ulp_u] < rank[ulp_v]){",
          "       parent[ulp_u] = ulp_v;",
          "     }else if(rank[ulp_u] > rank[ulp_v]){",
          "       parent[ulp_v] = ulp_u;",
          "     }else{",
          "       parent[ulp_v] = ulp_u;",
          "       rank[ulp_u]++;",
          "     }",
          "   }",
          "",
          "   void unionBySize(int u, int v){",
          "     int ulp_u = findPar(u);",
          "     int ulp_v = findPar(v);",
          "",
          "     if(ulp_u == ulp_v) return;",
          "     if(size[ulp_u] < size[ulp_v]){",
          "       parent[ulp_u] = ulp_v;",
          "       size[ulp_v] += size[ulp_u];",
          "     }else{",
          "       parent[ulp_v] = ulp_u;",
          "       size[ulp_u] += size[ulp_v];",
          "     }",
          "   }",
          "};",
        ],
        "description": "to add the disjoint set class in the cpp code"
        },
        "TwoSAT": {
          "prefix": "sat",
          "body": [
            "class TwoSAT {",
            "public:",
            "    int n;",
            "    vector<vector<int>> adj, adjT;",
            "    vector<int> ord, comp;",
            "    vector<bool> check, vis;",
            " ",
            "    TwoSAT(int n) : n(n), adj(2 * n), adjT(2 * n), check(n) {}",
            " ",
            "    void addClause(int u, bool uVal, int v, bool vVal) {",
            "        int uN = 2 * u + uVal;",
            "        int uNN = 2 * u + !uVal;",
            "        int vN = 2 * v + vVal;",
            "        int vNN = 2 * v + !vVal;",
            " ",
            "        adj[uNN].push_back(vN);",
            "        adj[vNN].push_back(uN);",
            " ",
            "        adjT[vN].push_back(uNN);",
            "        adjT[uN].push_back(vNN);",
            "    }",
            " ",
            "    void dfs1(int node) {",
            "        vis[node] = true;",
            "        for (int next : adj[node])",
            "            if (!vis[next])",
            "                dfs1(next);",
            "        ord.push_back(node);",
            "    }",
            " ",
            "    void dfs2(int node, int color) {",
            "        comp[node] = color;",
            "        for (int next : adjT[node])",
            "            if (comp[next] == -1)",
            "                dfs2(next, color);",
            "    }",
            " ",
            "    bool satisfy() {",
            "        vis.assign(2 * n, false);",
            "        comp.assign(2 * n, -1);",
            " ",
            "        for (int i = 0; i < 2 * n; ++i)",
            "            if (!vis[i])",
            "                dfs1(i);",
            " ",
            "        reverse(ord.begin(), ord.end());",
            " ",
            "        int color = 0;",
            "        for (int node : ord)",
            "            if (comp[node] == -1)",
            "                dfs2(node, color++);",
            " ",
            "        for (int i = 0; i < n; i++) {",
            "            if (comp[2 * i] == comp[2 * i + 1])",
            "                return false;  // x and ¬x are in the same SCC",
            "            check[i] = comp[2 * i] < comp[2 * i + 1];",
            "        }",
            " ",
            "        return true;",
            "    }",
            " ",
            "    void result() {",
            "        for (int i = 0; i < n; i++)",
            "            cout << \"Variable \" << i << \" is \" << (check[i] ? \"True\" : \"False\") << endl;",
            "    }",
            "};"
          ],
          "description": "TwoSAT"
        },
        "DAG": {
          "prefix": "dag",
          "body": [
            "class SCCmaker",
            "{",
            "    vector<vector<ll>> DAG;",
            "    vector<ll> info;",
            "    ll number_of_nodes;",
            "",
            "    void dfs(ll node, vector<vector<ll>> &adj, vector<ll> &vis, vector<ll> &order)",
            "    {",
            "        vis[node] = 1;",
            "        for (auto &i : adj[node])",
            "        {",
            "            if (vis[i] != 1)",
            "            {",
            "                dfs(i, adj, vis, order);",
            "            }",
            "        }",
            "        order.push_back(node);",
            "    }",
            "    void dfs2(ll node, vector<vector<ll>> &revadj, vector<ll> &temp, vector<ll> &vis)",
            "    {",
            "        vis[node] = 1;",
            "        temp.push_back(node);",
            "        for (auto &i : revadj[node])",
            "        {",
            "            if (vis[i] == 0)",
            "            {",
            "                dfs2(i, revadj, temp, vis);",
            "            }",
            "        }",
            "    }",
            "    ll combine(vector<ll> &temp, vector<ll> &information)",
            "    {",
            "        ll sum = 0;",
            "        for (auto &i : temp)",
            "        {",
            "            sum += information[i - 1];",
            "        }",
            "        return sum;",
            "    }",
            "public:",
            "    SCCmaker(vector<vector<ll>> &adj, vector<ll> &information, vector<pair<ll, ll>> &edges, ll n)",
            "    {",
            "        vector<ll> order;",
            "        vector<ll> vis(n + 1, 0);",
            "        for (ll i = 1; i <= n; i++)",
            "        {",
            "            if (!vis[i])",
            "                dfs(i, adj, vis, order);",
            "        }",
            "        reverse(order.begin(), order.end());",
            "        vector<ll> vis2(n + 1, 0);",
            "        vector<vector<ll>> revadj(n + 1);",
            "        for (auto &i : edges)",
            "        {",
            "            revadj[i.second].push_back(i.first);",
            "        }",
            "        vector<ll> parentset(n + 1, 0);",
            "        ll c = 0;",
            "        for (auto &i : order)",
            "        {",
            "            if (!vis2[i])",
            "            {",
            "                vector<ll> temp;",
            "                dfs2(i, revadj, temp, vis2);",
            "                ll z = temp.size();",
            "                for (ll j = 0; j < z; j++)",
            "                {",
            "                    parentset[temp[j]] = c;",
            "                }",
            "                ll sum = combine(temp, information);",
            "                info.push_back(sum);",
            "                c++;",
            "            }",
            "        }",
            "        DAG.resize(c);",
            "        number_of_nodes = c;",
            "        for (auto &i : edges)",
            "        {",
            "            if (parentset[i.first] != parentset[i.second])",
            "            {",
            "                DAG[parentset[i.first]].push_back(parentset[i.second]);",
            "            }",
            "        }",
            "    }",
            "    vector<vector<ll>> getDAG()",
            "    {",
            "        return DAG;",
            "    }",
            "    vector<ll> getinfo()",
            "    {",
            "        return info;",
            "    }",
            "    ll get_numberofnodes()",
            "    {",
            "        return number_of_nodes;",
            "    }",
            "};"
          ],
          "description": "DAG"
        },
        "Lazy": {
  "prefix": "lazy",
  "body": [
    "class Lazy{",
    "    vector<int> seg;",
    "    vector<int> lazy;",
    "    public:",
    "    // segment tree constructor for defining the size",
    "    Lazy(int n){",
    "        seg.assign(4 * n + 1, -1);",
    "        lazy.assign(4 * n + 1, 0);",
    "    }",
    "    // operation function",
    "    int comp(int a, int b){",
    "        return max(a, b);",
    "    }",
    "    // to propagate the lazy value",
    "    void propagate(int node, int val, int start, int end){",
    "        seg[node] += val;",
    "        if(start != end){",
    "            lazy[2 * node + 1] += val;",
    "            lazy[2 * node + 2] += val;",
    "        }",
    "    }",
    "    // for building the segment tree",
    "    void build(int ind, int left, int right, vector<int>& arr){",
    "        // when on the leaf node, add the value to the segment",
    "        if(left == right){",
    "            seg[ind] = arr[left];",
    "            return;",
    "        }",
    "        // now go on the build the left and right subtree",
    "        int mid = left + (right - left) / 2;",
    "        // left subtree",
    "        build(2 * ind + 1, left, mid, arr);",
    "        // right subtree",
    "        build(2 * ind + 2, mid + 1, right, arr);",
    "        // operation which you need to perform on the subtree",
    "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
    "    }",
    "    // for the query of the data",
    "    int query(int ind, int left, int right, int l, int r){",
    "        // when the segment is not in the range (disjoint)",
    "        if(r < left || l > right) return INT_MIN;",
    "        // propagate the lazy value",
    "        if(lazy[ind] != 0){",
    "            propagate(ind, lazy[ind], left, right);",
    "            lazy[ind] = 0;",
    "        }",
    "        // when fully in the range ",
    "        if(l <= left && right <= r){",
    "            return seg[ind];",
    "        }",
    "        // partial overlapping",
    "        int mid = left + (right - left) / 2;",
    "        int leftC = query(2 * ind + 1, left, mid, l, r);",
    "        int rightC = query(2 * ind + 2, mid + 1, right, l, r);",
    "        // operation which you need to perform on the subtree",
    "        return comp(leftC , rightC);",
    "    }",
    "    // range update for the tree",
    "    void update(int ind, int left, int right, int l, int r, int val){",
    "        // propagate the value",
    "        if(lazy[ind] != 0){",
    "            propagate(ind, lazy[ind], left, right);",
    "            lazy[ind] = 0;",
    "        }",
    "        // outside range",
    "        if(left > r || right < l || left > right) return;",
    "        // when on the leaf node, update the value",
    "        if(left >= l && right <= r){",
    "            propagate(ind, val, left, right);",
    "            return;",
    "        }",
    "        // now check on the left and right",
    "        int mid = left + (right - left) / 2;",
    "        // update the left and right child",
    "        update(2 * ind + 1, left, mid, l, r, val);",
    "        update(2 * ind + 2, mid + 1, right, l, r, val);",
    "        // operation which you need to perform on the tree",
    "        seg[ind] = comp(seg[2 * ind + 1], seg[2 * ind + 2]);",
    "    }",
    "};"
  ],
  "description": "lazy"
},
"hld": {
  "prefix": "hld",
  "body": [
    "class HLD{",
    "    public:",
    "    vector<int> parent, depth, heavy, head, pos, lt;",
    "    int cur_pos;",
    "    // dfs for computing the parent, depth, heavy nodes",
    "    int dfs(int node, vector<vector<int>>& adj){",
    "        int size = 1;",
    "        int max_c_size = 0;",
    "        for(auto &c: adj[node]){",
    "            if(c != parent[node]){",
    "                parent[c] = node;",
    "                depth[c] = depth[node] + 1;",
    "                int c_size = dfs(c, adj);",
    "                size += c_size;",
    "                if(c_size > max_c_size){",
    "                    max_c_size = c_size;",
    "                    heavy[node] = c;",
    "                }",
    "            }",
    "        }",
    "        return size;",
    "    }",
    "    // making head and pos node",
    "    // distributing the heavy and light nodes",
    "    void decompose(int node, int hnode, vector<vector<int>>& adj, vector<int>& arr){",
    "        head[node] = hnode;",
    "        lt[cur_pos] = arr[node];",
    "        pos[node] = cur_pos++;",
    "        if(heavy[node] != -1)",
    "            decompose(heavy[node], hnode, adj, arr);",
    "        for(auto &c: adj[node]){",
    "            if(c != parent[node] && c != heavy[node])",
    "                decompose(c, c, adj, arr);",
    "        }",
    "    }",
    "    public:",
    "    // initialization of the HLD",
    "    HLD(vector<vector<int>>& adj, vector<int>& arr){",
    "        int n = adj.size();",
    "        parent = vector<int>(n);",
    "        depth = vector<int>(n);",
    "        heavy = vector<int>(n, -1);",
    "        head = vector<int>(n);",
    "        pos = vector<int>(n);",
    "        lt = vector<int>(n);",
    "        cur_pos = 0;",
    "        dfs(0, adj);",
    "        decompose(0, 0, adj, arr);",
    "    }",
    "};",
    "",
    "class SGTree {  ",
    "    vector<int> seg;  ",
    "    vector<int> arr;  ",
    "    int n;  ",
    "",
    "public:  ",
    "    // Segment tree constructor for defining the size  ",
    "    SGTree(int size) : n(size) {  ",
    "        arr.assign(n, 0); // Store the original array  ",
    "        seg.assign(2 * n + 5, 0); // Segment tree array  ",
    "    }  ",
    "",
    "    // Operation function  ",
    "    int comp(int a, int b) {  ",
    "        return max(a, b);  ",
    "    }  ",
    "",
    "    // Build the segment tree iteratively  ",
    "    void build(vector<int>& input) {  ",
    "        arr = input;  ",
    "        // Fill segment tree leaves  ",
    "        for (int i = 0; i < n; ++i) {  ",
    "            seg[n + i] = arr[i];  ",
    "        }  ",
    "        // Build the rest of the tree in bottom-up manner  ",
    "        for (int i = n - 1; i > 0; --i) {  ",
    "            seg[i] = comp(seg[i << 1], seg[i << 1 | 1]);  ",
    "        }  ",
    "    }  ",
    "",
    "    // Query the segment tree iteratively  ",
    "    int query(int l, int r) {  ",
    "        int res = 0; // Assume we want the max, so start with 0  ",
    "        l += n; // Shift index to leaf  ",
    "        r += n; // Shift index to leaf  ",
    "        while (l <= r) {  ",
    "            if (l & 1) {  ",
    "                res = comp(res, seg[l++]); // Include l and move to right  ",
    "            }  ",
    "            if (!(r & 1)) {  ",
    "                res = comp(res, seg[r--]); // Include r and move to left  ",
    "            }  ",
    "            l >>= 1; // Move up to parent  ",
    "            r >>= 1;  ",
    "        }  ",
    "        return res;  ",
    "    }  ",
    "",
    "    // Point update for the tree  ",
    "    void update(int pos, int val) {  ",
    "        // Update value at position pos  ",
    "        arr[pos] = val;  ",
    "        pos += n; // Shift index to leaf  ",
    "        seg[pos] = val; // Update the value at the leaf  ",
    "        // Update the parent nodes  ",
    "        for (pos >>= 1; pos > 0; pos >>= 1) {  ",
    "            seg[pos] = comp(seg[pos << 1], seg[pos << 1 | 1]);  ",
    "        }  ",
    "    }  ",
    "};  ",
    "",
    "int HLDQuery(int a, int b, HLD& hld, SGTree& seg){",
    "    int mx = 0;",
    "    while(hld.head[a] != hld.head[b]){",
    "        if(hld.depth[hld.head[a]] > hld.depth[hld.head[b]])",
    "            swap(a, b);",
    "        // for processing the query calculation",
    "        mx = max(mx, seg.query(hld.pos[hld.head[b]], hld.pos[b]));",
    "        b = hld.parent[hld.head[b]];",
    "    }",
    "    if(hld.depth[a] > hld.depth[b])",
    "        swap(a, b);",
    "    mx = max(mx, seg.query(hld.pos[a], hld.pos[b]));",
    "    return mx;",
    "}"
  ],
  "description": "hld"
},
"FenwickTree": {
  "prefix": "BITTree",
  "body": [
    "class BIT{",
    "    vector<int> ftree;",
    "",
    "    public:",
    "    // Initialize the fenwick tree",
    "    BIT(vector<int>& arr){",
    "        int n = arr.size();",
    "        ftree = vector<int>(n+1, 0);",
    "        build(arr);",
    "    }",
    "    // building the fenwick tree",
    "    void build(vector<int>& arr){",
    "        int n = arr.size();",
    "        for(int i=0; i<n; i++)",
    "            update(i, arr[i]);",
    "    }",
    "    // point update over fenwick tree",
    "    void update(int idx, int val){",
    "        idx++;",
    "        int n = ftree.size();",
    "        while(idx < n){",
    "            ftree[idx] += val;",
    "            idx += (idx & -idx);",
    "        }",
    "    }",
    "    // 0...a prefix query on fenwick tree",
    "    int query(int a){",
    "        a++;",
    "        int sum = 0;",
    "        while(a > 0){",
    "            sum += ftree[a];",
    "            a -= (a & -a);",
    "        }",
    "        return sum;",
    "    }",
    "};"
  ],
  "description": "FenwickTree"
},
"BIT2D": {
  "prefix": "BIT2D",
  "body": [
    "class TwoBIT{",
    "    public:",
    "    // make it one based indexing for better calculation",
    "    // for both farr and arr",
    "    vector<vector<int>> farr;",
    "    TwoBIT(vector<vector<int>>& arr){",
    "        int n = arr.size();",
    "        int m = arr[0].size();",
    "        farr = vector<vector<int>>(n, vector<int>(m, 0));",
    "        build(arr);",
    "    }",
    "    // build of 2D fenwick tree",
    "    // Complexity - O(n * m * logn * logm)",
    "    void build(vector<vector<int>>& arr){",
    "        int n = arr.size();",
    "        for(int i=1; i<n; i++){",
    "            int m = arr[i].size();",
    "            for(int j=1; j<m; j++) ",
    "                update(i, j, arr[i][j]);",
    "        }",
    "    }",
    "    // point update",
    "    // Complexity - O(logn * logm)",
    "    // need to update the change, not the value",
    "    // like if the value already is x, and want to make y, then change it to y - x",
    "    void update(int x, int y, int val){",
    "        int nx = x;",
    "        int n = farr.size();",
    "        while(nx < n){",
    "            int ny = y;",
    "            int m = farr[nx].size();",
    "            while(ny < m){",
    "                farr[nx][ny] += val;",
    "                ny += (ny & -ny);",
    "            }",
    "            nx += (nx & -nx);",
    "        }",
    "    }",
    "    // 2D range sum query",
    "    // Complexity - O(logn * logm)",
    "    int query(int x1, int y1, int x2, int y2){",
    "        // p[x2][y2] - p[x2][y1-1] - p[x1-1][y2] + p[x1-1][y1-1]",
    "        int inc1 = query(x2, y2);",
    "        int exc1 = query(x2, y1 - 1);",
    "        int exc2 = query(x1 - 1, y2);",
    "        int inc2 = query(x1 - 1, y1 - 1);",
    "        return inc1 - exc1 - exc2 + inc2;",
    "    }",
    "    // prefix query",
    "    // Complexity - O(logn * logm)",
    "    int query(int x, int y){",
    "        int nx = x;",
    "        int sum = 0;",
    "        while(nx > 0){",
    "            int ny = y;",
    "            while(ny > 0){",
    "                sum += farr[nx][ny];",
    "                ny -= (ny & -ny);",
    "            }",
    "            nx -= (nx & -nx);",
    "        }",
    "        return sum;",
    "    }",
    "};"
  ],
  "description": "BIT2D"
},
"Persistant Segment Tree": {
  "prefix": "pst",
  "body": [
    "class Node{",
    "    public:",
    "    int sum;",
    "    Node* left;",
    "    Node* right;",
    "    Node(int data){",
    "        sum = data;",
    "        left = right = NULL;",
    "    }",
    "    Node(Node* l, Node* r){",
    "        sum = l -> sum + r -> sum;",
    "        left = l;",
    "        right = r;",
    "    }",
    "};",
    "",
    "class PST{",
    "    public:",
    "    Node* build(int start, int end, vector<int>& arr){",
    "        if(start == end) return new Node(arr[start]);",
    "        else{",
    "            int mid = start + (end - start) / 2;",
    "            return new Node(build(start, mid, arr), build(mid + 1, end, arr));",
    "        }",
    "    }",
    "    Node* update(Node* root, int start, int end, int pos, int val){",
    "        if(start == end) return new Node(val);",
    "        else{",
    "            int mid = start + (end - start) / 2;",
    "            if(start <= pos && pos <= mid)",
    "                return new Node(update(root -> left, start, mid, pos, val), root -> right);",
    "            else",
    "                return new Node(root -> left, update(root -> right, mid + 1, end, pos, val));",
    "        }",
    "    }",
    "    int query(Node* root, int start, int end, int l, int r){",
    "        if(start > r || end < l) return 0;",
    "        if(start >= l && end <= r) return root -> sum;",
    "        int mid = start + (end - start) / 2;",
    "        return query(root -> left, start, mid, l, r) + query(root -> right, mid + 1, end, l, r);",
    "    }",
    "};"
  ],
  "description": "Persistant Segment Tree"
}
}
